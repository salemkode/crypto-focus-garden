pragma cashscript ^0.13.0;

// PomodoroRewards: Public pool for Pomodoro-style NFT rewards
contract PomodoroRewards(
    bytes32 categoryId,   // Token category for the NFT rewards (32 bytes only)
    // int unlockDelay       // delay in seconds before claim is allowed (e.g. 1500 = 25 minutes)
) {
    // -----------------------------------------------------------------------------------
    // 1) mintAndLockReward: Create (mint) and Lock a reward in one step.
    //    - Requires a user UTXO with vout=0 to be spent (proof of "genesis" or eligibility)
    //    - The reward is immediately locked to the user and current timestamp.
    //
    // Inputs:
    //  0: Baton UTXO       [NFT] (from this contract)
    //  1: User UTXO        [BCH] (from user, MUST have vout=0)
    //
    // Outputs:
    //  0: Baton UTXO       [NFT] (back to this contract)
    //  1: Locked NFT       [NFT] (locked in this contract, commitment = 0x01 || userPkh || ts)
    //  2+: Optional BCH change back to user (no tokens allowed)
    // -----------------------------------------------------------------------------------
    function mintAndLockReward() {
        // Ensure this input is the covenant itself (recursive covenant check)
        require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[0].lockingBytecode);

        // Input 0 must be the baton from the same category
        bytes32 in0Cat = tx.inputs[0].tokenCategory.split(32)[0];
        require(in0Cat == categoryId);

        // Output 0: Baton UTXO (recursive)
        // - Same locking bytecode (same contract)
        // - Same category (first 32 bytes)
        // - Same value and tokenAmount (baton preserved)
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
        bytes32 out0Cat = tx.outputs[0].tokenCategory.split(32)[0];
        require(out0Cat == categoryId);
        require(tx.outputs[0].value == tx.inputs[0].value);
        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);

        // Output 1: Locked NFT (minted & locked)
        // - Locked in this contract
        // - Same category (first 32 bytes)
        // - tokenAmount == 0 (NFT)
        require(tx.outputs[1].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
        bytes32 out1Cat = tx.outputs[1].tokenCategory.split(32)[0];
        require(out1Cat == categoryId);
        require(tx.outputs[1].tokenAmount == 0);

        // Input 1: User UTXO (proof-of-eligibility)
        // - Must be simple BCH (no tokens)
        // - Must be from P2PKH(pubkeyhash)
        require(tx.inputs[1].tokenCategory == 0x);

        // Build commitment: 0x01 || hash160(user) || uint32(timestampStart)
        // Using tx.locktime as the session start timestamp
        int time = tx.locktime;
        bytes ts = bytes(tx.locktime);
        console.log(ts);
        console.log(time);
        bytes expectedCommitment = 0x01 + tx.inputs[1].lockingBytecode + ts;

        bytes commitment = tx.outputs[1].nftCommitment;
        console.log(commitment, expectedCommitment);
        require(commitment == expectedCommitment);

        // Ensure no other outputs (index >= 2) contain tokens or same covenant bytecode
        int o = 2;

        do {
            // No extra covenant outputs
            require(tx.outputs[o].lockingBytecode != tx.inputs[this.activeInputIndex].lockingBytecode);
            // No tokens in any other output
            require(tx.outputs[o].tokenCategory == 0x);
            o = o + 1;
        } while (o < tx.outputs.length);
    }

    // -----------------------------------------------------------------------------------
    // 2) claimReward: user claims the locked reward after unlockDelay
    //
    // Inputs:
    //  0: Locked NFT       [NFT] (from this contract, commitment=0x01 || userPkh || ts)
    //
    // Outputs:
    //  0: User NFT         [NFT] (to User's P2PKH address)
    //  1+: Optional BCH change (no tokens allowed)
    // -----------------------------------------------------------------------------------
    function claimReward() {
        // Input 0 must be from the correct token category (first 32 bytes)
        bytes32 in0Cat = tx.inputs[0].tokenCategory.split(32)[0];
        require(in0Cat == categoryId);

        // Extract commitment from input 0
        bytes commitment = tx.inputs[0].nftCommitment;

        // version = first byte, data = rest
        bytes version, bytes data = commitment.split(1);
        require(version == 0x01);

        // userPkhBytes = first 20 bytes of data, tsBytes = remaining 4 bytes (timestamp)
        // bytes lockingBytecode, bytes tsBytes = data.split(25);
        bytes lockingBytecode = data.split(25)[0];

        // Verify claiming user matches locked user
        require(lockingBytecode == tx.outputs[0].lockingBytecode);

        // Check time delay: tx.locktime >= startTime + unlockDelay
        // int startTime = int(bytes(tsBytes));
        // For now we do not need put timer it just 100ms
        // ! TODO: require(tx.locktime >= finalTime);
        // int finalTime = startTime + unlockDelay;
        // console.log(tx.locktime, finalTime);
        require(tx.locktime >= 100);

        // Output 0: Send NFT to user
        bytes32 out0Cat = tx.outputs[0].tokenCategory.split(32)[0];

        console.log(out0Cat, categoryId);
        require(out0Cat == categoryId);
        require(tx.outputs[0].tokenAmount == 0);            // NFT
        require(tx.outputs[0].value == tx.inputs[0].value); // preserve BCH amount

        // Ensure no other outputs contain tokens
        if (tx.outputs.length > 1) {
            int o = 1;
            do {
                require(tx.outputs[o].tokenCategory == 0x);
                o = o + 1;
            } while (o < tx.outputs.length);
        }
    }
}
